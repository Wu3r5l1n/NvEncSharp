using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;

namespace Lennox.NvEncSharp.Test
{
    internal static class CodeGeneration
    {
        public static string LoadNvencHeader()
        {
            var assembly = typeof(CodeGeneration).Assembly;
            var name = assembly.GetManifestResourceNames()
                .Single(t => t.EndsWith("nvEncodeAPI.h"));
            using var stream = assembly.GetManifestResourceStream(name);
            using var sr = new StreamReader(stream);
            return sr.ReadToEnd();
        }

        public static void WriteNvencHeaderOutput(
            StringBuilder output,
            string filename,
            [CallerFilePath] string callerPath = "")
        {
            var dest = Path.Combine(
                Path.GetDirectoryName(callerPath),
                "..", "NvEncSharp", filename);

            File.WriteAllText(dest, output.ToString().Trim());
        }

        public static string GetComment(string def, ref int i)
        {
            i += 2;
            var end = def.IndexOf("*/", i);

            var comment = def.Substring(i + 2, end - i - 2);
            var excessiveSpaces = new Regex("[ ]+");
            comment = excessiveSpaces.Replace(comment, " ");

            i = end + 1;

            SkipWhitespace(def, ref i);

            return comment.Trim().Trim('*', '<');
        }

        public static void SkipWhitespace(string def, ref int i)
        {
            for (++i; i < def.Length; ++i)
            {
                var chr = def[i];
                if (!char.IsWhiteSpace(chr))
                {
                    --i;
                    return;
                }
            }
        }

        public static void AppendHeader(
            StringBuilder output,
            [CallerMemberName] string callerName = "",
            [CallerFilePath] string callerPath = "")
        {
            output.Append($"using System;\r\n");
            output.Append($"using System.Runtime.InteropServices;\r\n");
            output.Append($"\r\n");
            output.Append($"/*******\r\n");
            output.Append($" * This file is generated by {Path.GetFileName(callerPath)}:{callerName}.\r\n");
            output.Append($" * Please do not hand edit.\r\n");
            output.Append($" *******/\r\n");
            output.Append($"\r\n");
            output.Append($"// ReSharper disable UnusedMember.Global\r\n");
            output.Append($"namespace Lennox.NvEncSharp\r\n");
            output.Append($"{{\r\n");
        }

        // The generated names can't start with a number per C#.
        private static readonly Regex _isNumber = new Regex(@"^_?\d+", RegexOptions.Compiled);

        // Names which don't translate correctly using the typical pattern.
        private static readonly Dictionary<string, string> _fixedNames = new Dictionary<string, string>
        {
            { "NVENCSTATUS", "NvEncStatus" }
        };

        // Name prefixes that can't be determined by the typical pattern.
        private static readonly Dictionary<string, string> _fixedPrefix = new Dictionary<string, string>
        {
            { "NVENCSTATUS", "NV_ENC_ERR" }
        };

        public static string FixStructMemeberName(string s)
        {
            return (char.ToUpper(s[0]) + s.Substring(1))
                .Replace("GUID", "Guid");
        }

        public static string Fixname(string s, string prefix = null)
        {
            const string badprefix = "NVENC_";

            // Fix the inconsistent use of NVENC_ and NV_ENC.
            if (s.StartsWith(badprefix))
            {
                s = "NV_ENC_" + s.Substring(badprefix.Length);
            }

            if (_fixedNames.TryGetValue(s, out var fixedName)) return fixedName;
            if (prefix != null && _fixedPrefix.TryGetValue(prefix, out var fixedPrefix)) prefix = fixedPrefix;

            // Fix a name that translates oddly.
            s = s.Replace("SESSIONEX", "SESSION_EX");

            var sb = new StringBuilder();
            var nextUppercase = true;

            var oldname = s;

            // If there's a prefix, split it apart and remove best possible
            // matching portion from the input name.
            if (prefix != null)
            {
                var prefixSplit = prefix.Split('_');
                var prefixMini = prefixSplit.Length > 1
                    ? string.Join("_", prefixSplit.Take(prefixSplit.Length - 1))
                    : null;

                if (s.StartsWith(prefix))
                {
                    s = s.Substring(prefix.Length);
                }
                else if (prefixMini != null && s.StartsWith(prefixMini) || s == "_")
                {
                    s = s.Substring(prefixMini.Length);
                }

                // Handle stuff like _NV_ENC_EMPHASIS_MAP_LEVEL.NV_ENC_EMPHASIS_MAP_LEVEL_1 and
                // NV_ENC_QP_MAP_MODE.NV_ENC_QP_MAP
                if (_isNumber.IsMatch(s) || string.IsNullOrWhiteSpace(s))
                {
                    var namesplit = oldname.Split('_');
                    s = string.Join("_", namesplit.Skip(namesplit.Length - 2).Take(2));
                }
            }

            s = s.Trim('_');

            for (var i = 0; i < s.Length; ++i)
            {
                var chr = s[i];

                if (nextUppercase)
                {
                    nextUppercase = false;
                    chr = char.ToUpper(chr);
                }
                else
                {
                    chr = char.ToLower(chr);
                }

                if (chr == '_')
                {
                    nextUppercase = true;
                    continue;
                }

                sb.Append(chr);
            }

            return sb.ToString();
        }

        public static string CleanupComment(string s, string spacing)
        {
            if (string.IsNullOrWhiteSpace(s)) return null;

            var lines = s
                .Split(new[] { "\r\r\n", "\r\n", "\r" }, StringSplitOptions.RemoveEmptyEntries)
                .Select(t => t.Trim(' ', '\r', '*', '/', '\\'))
                .Where(t => !string.IsNullOrWhiteSpace(t))
                .Select(t => $"{spacing}/// {t}")
                .ToArray();

            return string.Join("\r\n", lines);
        }
    }
}